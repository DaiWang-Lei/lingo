import { Group } from "three";
import fit from "./utils/fit";
import Loaded from "./core/Loaded";
import { lazy } from "@lincode/utils";
import AnimationManager from "./core/SimpleObjectManager/AnimationManager";
import { scaleDown } from "../engine/constants";
import { modelDefaults } from "../interface/IModel";
import { objectURLMapperPtr } from "./utils/loaders/setObjectURLMapper";
import { Resolvable } from "@lincode/promiselikes";
const lazyLoadFBX = lazy(() => import("./utils/loaders/loadFBX"));
const lazyLoadGLTF = lazy(() => import("./utils/loaders/loadGLTF"));
export default class Model extends Loaded {
    async loadAnimation(url, name = url) {
        var _a;
        const resolvable = new Resolvable();
        ((_a = this.loadingAnims) !== null && _a !== void 0 ? _a : (this.loadingAnims = [])).push(resolvable);
        let data;
        try {
            data = await this.load(url);
        }
        catch {
            resolvable.resolve();
            return;
        }
        const clip = data.animations[0];
        clip && (this.animations[name] = this.watch(new AnimationManager(clip, await this.loadedResolvable)));
        resolvable.resolve();
    }
    get animations() {
        var _a;
        return (_a = this.animationManagers) !== null && _a !== void 0 ? _a : (this.animationManagers = {});
    }
    set animations(val) {
        for (const [key, value] of Object.entries(val))
            if (typeof value === "string")
                this.loadAnimation(value, key);
            else
                this.animations[key] = value;
    }
    async load(url) {
        var _a;
        const resolvable = new Resolvable();
        ((_a = this.loadingAnims) !== null && _a !== void 0 ? _a : (this.loadingAnims = [])).push(resolvable);
        let result;
        try {
            if (objectURLMapperPtr[0](url).endsWith(".fbx"))
                result = await (await lazyLoadFBX()).default(url);
            else
                result = await (await lazyLoadGLTF()).default(url);
        }
        catch {
            resolvable.resolve();
            return new Group();
        }
        resolvable.resolve();
        return result;
    }
    get loadedScale() {
        return this._loadedScale;
    }
    set loadedScale(val) {
        this._loadedScale = val;
    }
    get loadedX() {
        return this._loadedX;
    }
    set loadedX(val) {
        this._loadedX = val;
        this._loadedPos = true;
    }
    get loadedY() {
        return this._loadedY;
    }
    set loadedY(val) {
        this._loadedY = val;
        this._loadedPos = true;
    }
    get loadedZ() {
        return this._loadedZ;
    }
    set loadedZ(val) {
        this._loadedZ = val;
        this._loadedPos = true;
    }
    resolveLoaded(loadedObject3d) {
        for (const clip of loadedObject3d.animations)
            this.animations[clip.name] = this.watch(new AnimationManager(clip, loadedObject3d));
        if (this._loadedScale)
            loadedObject3d.scale.multiplyScalar(this._loadedScale);
        else {
            const size = fit(loadedObject3d, this._src);
            !this.widthSet && (this.object3d.scale.x = size.x);
            !this.heightSet && (this.object3d.scale.y = size.y);
            !this.depthSet && (this.object3d.scale.z = size.z);
        }
        if (this._loadedPos) {
            let { x, y, z } = loadedObject3d.position;
            this._loadedX && (x = this._loadedX * scaleDown);
            this._loadedY && (y = this._loadedY * scaleDown);
            this._loadedZ && (z = this._loadedZ * scaleDown);
            loadedObject3d.position.set(x, y, z);
        }
        this.loadedGroup.add(loadedObject3d);
        this.loadedResolvable.resolve(loadedObject3d);
    }
}
Model.componentName = "model";
Model.defaults = modelDefaults;
