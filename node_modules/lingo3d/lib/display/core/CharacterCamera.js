import { deg2Rad } from "@lincode/math";
import { debounce } from "@lincode/utils";
import { Quaternion } from "three";
import Camera from "../cameras/Camera";
import { euler, quaternion, quaternion_ } from "../utils/reusables";
export default class CharacterCamera extends Camera {
    constructor() {
        super(...arguments);
        this.setTarget = debounce(() => {
            var _a, _b;
            let i = 0;
            for (const child of [(_a = this._target) === null || _a === void 0 ? void 0 : _a.outerObject3d, ...this.camera.children]) {
                const object = child === null || child === void 0 ? void 0 : child.userData.manager;
                if (!object || object.done)
                    continue;
                if (++i === 1) {
                    (_b = this.outerObject3d.parent) === null || _b === void 0 ? void 0 : _b.add(object.outerObject3d);
                    this.target = object;
                }
                else
                    object.z = -100;
            }
            i === 0 && (this.target = undefined);
        }, 0, "trailing");
    }
    get target() {
        return this._target;
    }
    set target(target) {
        var _a;
        if (target === this._target)
            return;
        this._target = target;
        (_a = this.targetHandle) === null || _a === void 0 ? void 0 : _a.cancel();
        if (!target)
            return;
        this.queueMicrotask(() => this.outerObject3d.quaternion.copy(target.outerObject3d.quaternion));
        this.targetHandle = this.loop(() => {
            this.outerObject3d.position.copy(target.outerObject3d.position);
            euler.setFromQuaternion(this.outerObject3d.quaternion);
            euler.x = 0;
            euler.z = 0;
            euler.y += Math.PI;
            target.outerObject3d.quaternion.setFromEuler(euler);
        });
        target.frustumCulled = false;
    }
    append(object) {
        super.append(object);
        this.setTarget();
    }
    get gyroControl() {
        return !!this._gyroControl;
    }
    set gyroControl(val) {
        var _a;
        if (this._gyroControl === val)
            return;
        this._gyroControl;
        (_a = this.gyroControlHandle) === null || _a === void 0 ? void 0 : _a.cancel();
        const deviceEuler = euler;
        const deviceQuaternion = quaternion;
        const screenTransform = quaternion_;
        const worldTransform = new Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
        const quat = this.object3d.getWorldQuaternion(quaternion).clone();
        const orient = 0;
        const cb = (e) => {
            var _a, _b, _c;
            this.object3d.quaternion.copy(quat);
            deviceEuler.set(((_a = e.beta) !== null && _a !== void 0 ? _a : 0) * deg2Rad, ((_b = e.alpha) !== null && _b !== void 0 ? _b : 0) * deg2Rad, -((_c = e.gamma) !== null && _c !== void 0 ? _c : 0) * deg2Rad, "YXZ");
            this.object3d.quaternion.multiply(deviceQuaternion.setFromEuler(deviceEuler));
            const minusHalfAngle = -orient * 0.5;
            screenTransform.set(0, Math.sin(minusHalfAngle), 0, Math.cos(minusHalfAngle));
            this.object3d.quaternion.multiply(screenTransform);
            this.object3d.quaternion.multiply(worldTransform);
        };
        window.addEventListener("deviceorientation", cb);
        this.gyroControlHandle = this.cancellable(() => window.removeEventListener("deviceorientation", cb));
    }
}
