import { deg2Rad, rad2Deg } from "@lincode/math";
import { Reactive } from "@lincode/reactivity";
import { applyMixins, debounce } from "@lincode/utils";
import { PerspectiveCamera, Vector3 } from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { camFar, camNear, scaleDown, scaleUp } from "../../engine/constants";
import { container } from "../../engine/render/renderSetup";
import { getCamera } from "../../states/useCamera";
import EventLoopItem from "../../api/core/EventLoopItem";
import CameraMixin from "../core/mixins/CameraMixin";
import { orbitCameraDefaults } from "../../interface/IOrbitCamera";
import { loop } from "../../engine/eventLoop";
import { getOrbitControlsEnabled } from "../../states/useOrbitControlsEnabled";
import { vector3 } from "../utils/reusables";
import { emitOrbitControls } from "../../events/onOrbitControls";
import { setSelectionEnabled } from "../../states/useSelectionEnabled";
import mainCamera from "../../engine/mainCamera";
class OrbitCamera extends EventLoopItem {
    constructor(camera = new PerspectiveCamera(75, 1, camNear, camFar)) {
        super();
        this.camera = camera;
        this.updateDebounced = debounce(() => this.controls.update(), 0, "trailing");
        this.enableZoomState = new Reactive(false);
        this.enabledState = new Reactive(true);
        this.outerObject3d = camera;
        const controls = this.controls = new OrbitControls(camera, container);
        controls.enabled = false;
        controls.enablePan = false;
        controls.enableZoom = false;
        this.initOuterObject3d();
        this.initCamera();
        camera.position.z = 5;
        this.updateDebounced();
        this.createEffect(() => {
            if (!getOrbitControlsEnabled() || getCamera() !== camera || !this.enabledState.get())
                return;
            controls.enabled = true;
            const handle = loop(this.updateDebounced);
            if (this.enableZoomState.get()) {
                const cb = (e) => {
                    e.preventDefault();
                    const direction = camera.getWorldDirection(vector3);
                    let pt = camera.position.clone().add(direction.clone().multiplyScalar(-e.deltaY * scaleDown));
                    const localPt = camera.worldToLocal(pt.clone());
                    const localTarget = camera.worldToLocal(controls.target.clone());
                    if (localPt.z - localTarget.z <= 0)
                        pt = controls.target.clone().add(direction.multiplyScalar(-0.001));
                    camera.position.copy(pt);
                    this.updateDebounced();
                };
                container.addEventListener("wheel", cb);
                handle.then(() => container.removeEventListener("wheel", cb));
            }
            return () => {
                controls.enabled = false;
                handle.cancel();
            };
        }, [getCamera, getOrbitControlsEnabled, this.enableZoomState.get, this.enabledState.get]);
        let azimuthStart = 0;
        let polarStart = 0;
        let targetStart = vector3;
        let started = false;
        controls.addEventListener("start", () => {
            started = true;
            azimuthStart = controls.getAzimuthalAngle() * rad2Deg;
            polarStart = controls.getPolarAngle() * rad2Deg;
            targetStart = controls.target.clone();
            camera === mainCamera && emitOrbitControls("start");
        });
        controls.addEventListener("change", () => {
            if (!started)
                return;
            const azimuthDiff = Math.abs(controls.getAzimuthalAngle() * rad2Deg - azimuthStart);
            const polarDiff = Math.abs(controls.getPolarAngle() * rad2Deg - polarStart);
            const { x, y, z } = controls.target;
            const { x: x0, y: y0, z: z0 } = targetStart;
            const targetDiff = Math.max(Math.abs(x0 - x), Math.abs(y0 - y), Math.abs(z0 - z));
            if (azimuthDiff > 2 || polarDiff > 2 || targetDiff > 0.02) {
                setSelectionEnabled(false);
                camera === mainCamera && emitOrbitControls("move");
            }
        });
        controls.addEventListener("end", () => {
            started = false;
            setSelectionEnabled(true);
            camera === mainCamera && emitOrbitControls("stop");
        });
        this.then(() => controls.dispose());
    }
    get targetX() {
        var _a;
        return (_a = this._targetX) !== null && _a !== void 0 ? _a : (this._targetX = 0);
    }
    set targetX(val) {
        this._targetX = val;
        this.controls.target.x = val * scaleDown;
    }
    get targetY() {
        var _a;
        return (_a = this._targetY) !== null && _a !== void 0 ? _a : (this._targetY = 0);
    }
    set targetY(val) {
        this._targetY = val;
        this.controls.target.y = val * scaleDown;
    }
    get targetZ() {
        var _a;
        return (_a = this._targetZ) !== null && _a !== void 0 ? _a : (this._targetZ = 0);
    }
    set targetZ(val) {
        this._targetZ = val;
        this.controls.target.z = val * scaleDown;
    }
    get target() {
        return this._target;
    }
    set target(target) {
        var _a;
        this._target = target;
        this.controls.target = (_a = target === null || target === void 0 ? void 0 : target.outerObject3d.position) !== null && _a !== void 0 ? _a : new Vector3();
    }
    append(object) {
        var _a;
        if (this._target) {
            super.append(object);
            return;
        }
        (_a = this.outerObject3d.parent) === null || _a === void 0 ? void 0 : _a.add(object.outerObject3d);
        this.target = object;
    }
    get x() {
        return this.camera.position.x * scaleUp;
    }
    set x(val) {
        this.camera.position.x = val * scaleDown;
    }
    get y() {
        return this.camera.position.y * scaleUp;
    }
    set y(val) {
        this.camera.position.y = val * scaleDown;
    }
    get z() {
        return this.camera.position.z * scaleUp;
    }
    set z(val) {
        this.camera.position.z = val * scaleDown;
    }
    get rotationX() {
        return this.camera.rotation.x * rad2Deg;
    }
    get rotationY() {
        return this.camera.rotation.y * rad2Deg;
    }
    get rotationZ() {
        return this.camera.rotation.z * rad2Deg;
    }
    get enableDamping() {
        return this.controls.enableDamping;
    }
    set enableDamping(val) {
        this.controls.enableDamping = val;
    }
    get enablePan() {
        return this.controls.enablePan;
    }
    set enablePan(val) {
        this.controls.enablePan = val;
    }
    get enableZoom() {
        return this.enableZoomState.get();
    }
    set enableZoom(val) {
        this.enableZoomState.set(val);
    }
    get enabled() {
        return this.enabledState.get();
    }
    set enabled(val) {
        this.enabledState.set(val);
    }
    get autoRotate() {
        return this.controls.autoRotate;
    }
    set autoRotate(val) {
        this.controls.autoRotate = val;
    }
    get autoRotateSpeed() {
        return this.controls.autoRotateSpeed;
    }
    set autoRotateSpeed(val) {
        this.controls.autoRotateSpeed = val;
    }
    setRotationY(val, lock) {
        this.controls.minAzimuthAngle = this.controls.maxAzimuthAngle = val * deg2Rad;
        this.controls.update();
        if (lock)
            return;
        this.queueMicrotask(() => {
            this.controls.minAzimuthAngle = -Infinity;
            this.controls.maxAzimuthAngle = Infinity;
        });
    }
    setRotationX(val, lock) {
        this.controls.minPolarAngle = this.controls.maxPolarAngle = (val + 90) * deg2Rad;
        this.controls.update();
        if (lock)
            return;
        this.queueMicrotask(() => {
            this.controls.minPolarAngle = -Infinity;
            this.controls.maxPolarAngle = Infinity;
        });
    }
    setDistance(val, lock) {
        this.controls.minDistance = this.controls.maxDistance = val * scaleDown;
        this.controls.update();
        if (lock) {
            this.enableZoom = false;
            return;
        }
        this.queueMicrotask(() => {
            this.controls.minDistance = -Infinity;
            this.controls.maxDistance = Infinity;
        });
    }
}
OrbitCamera.componentName = "orbitCamera";
OrbitCamera.defaults = orbitCameraDefaults;
applyMixins(OrbitCamera, [CameraMixin]);
export default OrbitCamera;
